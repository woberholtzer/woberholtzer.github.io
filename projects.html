<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="...">
    <title>William F. Oberholtzer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="sidenav">
        <a href="">Menu</a>
        <a href="index.html">Homepage</a>
        <a href="about.html">About Me</a>
        <a href="projects.html">Projects</a>
      </div>
      
      <!-- Page content -->
      <div class="main">
        ...
      </div>
    <h3 class="header-main">William Oberholtzer</h3>
    <h3 class="header-main">Contact at <b>wioberholtzer@ursinus.edu</b></h3>
    <div class="long-box"></div>
    <section>
        <h1 class="name-main">Projects</h1>
        <h2 class="headline">Here is a collection of some of my work
            thus far. More details can be found <a href="https://github.com/woberholtzer">
                here</a>
        </h2>
        <div class="dotted-box"></div>
        <img src="images/Cells_Marked.png" alt="haha" class="img-projects">
        <h3 class="sector-main">Plant Cell Segmentation</h3>
        <p class="text-main extend-page"> 
            This project utilizes the Disjoint Set data structure and 
            watershed segmentation to locate and match pixels of a high 
            brightness threshold. The cells are located and the center of 
            the cell is represented by a green dot. The unionfind
            implementation can be found in 
            <a href="https://github.com/woberholtzer/Cell-Segmentation/blob/main/unionfindeff.py">
                unionfindeff.py</a>, which utilizes a weights system to
            allow for the shortening of the roots, which ultimately results in
            greater efficiency when performing the union of two elements. The 
            watershed segmentation implementation can be found at
            <a href="https://github.com/woberholtzer/Cell-Segmentation/blob/main/cells.py">
                cells.py</a>      
        </p>
        <p class="extend-page"></p>
        <div class="dotted-box"></div>
        <img src="images/manhattan_art.png" alt="haha" class="img-projects-art">
        <h3 class="sector-main">Traveling Salesperson Art</h3>
        <p class="text-main extend-page"> 
            Both Depth First Search and Minimum Spanning Trees are
            implemented in this project to create art. First, an image is taken
            and is converted into a map of dots, where dots represent dark areas of
            image. The dots are collected and stored in an array by relative location
            in image. A Minimum Spanning Tree is generated from this array, and then
            A Depth First Search is performed on the generated tree. Lastly, the
            improved connections are further optimized by removing all crossings that
            may generate after the Depth First Search. Full Project can be found
            <a href="https://github.com/woberholtzer/Cell-Segmentation/blob/main/cells.py">
                here</a> 
        </p>
        <p class="extend-page"></p>
        <div class="dotted-box"></div>
        <img src="images/homergif.gif" alt="haha" class="img-projects-art-homer">
        <h3 class="sector-main">Character Animation</h3>
        <p class="text-main extend-page"> 
            This project uses Forward And Backward Reaching Inverse Kinematics (FABRIK)
            to animate a Homer Simpson mesh. A data structure is first created to efficently
            store joint positions, names, and "leaf" status (whether or not the joint has multiple
            children). Then, FABRIK is applied to move joint "chains", which are a group of leaf
            joints attached to each other. Once this is done, the skeleton outline of the Homer Simpson
            mesh will move accordingly. To move the mesh vertices along with the bones, transformation
            matrices are created, which are translated from "world" coordinates to "bone" coordinates, with bones
            holding the position, among other information, of two connected joints. Then, assuming FABRIK is 
            applied, the matrices of the mesh vertices are translated back to "bone" coordinates from "world" 
            coordinates with respect to the nearest bone for a given vertex. More details can be found
            
            
            <a href="https://github.com/woberholtzer/character-animation">
                here</a> 
        </p>
    </section>   
</body>
</html>
